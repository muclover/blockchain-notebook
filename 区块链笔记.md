# 区块链笔记

## 一、比特币（Bitcoin）

### 1.1 BTC中的密码学

- **哈希函数**
  - three properties：
    1. 输入任意大小的字符串
    2. 产生固定长度的输出
    3. 高效可计算的。
  - For a hash function to be cryptographically secure, we’re going to require that it has the following three additional properties:
    - (1) collision‐resistance：抗碰撞性：找到x!=y使得H(x)=H(y)是不可行的
      - （birthday paradox ）
      - 可用于做消息摘要：检测对文件的篡改
    - (2) hiding：单向性，由x计算H(x)容易，反推不可行
      - 1+2可用作digital commitment
    - (3) puzzle‐friendliness：除了一个个尝试，并没有其他更好的办法来解决
      - 用于计算力的搜索

> **SHA-256算法**
>
> **RIRPEMD-160算法**

- **公钥密码学**

在BTC中，我们通过使用公钥密码学创建一个公私钥对，创建一个个人账户，公钥可以看成账号地址，用来接受比特币，私钥则用于支付比特币时的交易签名。

公钥一般都会经过SHA256算法进行散列化，产生用户的地址。

BTC中使用的是**椭圆曲线数字签名方法**

- **数字签名**

Bob拥有一对公私钥，公私钥可以互相的加解密，其中公钥是公开的，私钥可以用于对数据文件进行签名来表明身份。对一份数据x，通过私钥进行加密为签名，然后再将签名和数据x发送出去，当接收方收到数据x和签名后，使用Bob公开的公钥对签名进行解密，若成功解密出x，则证明此数据x来自与Bob。

- Q:Attacker可以在中途截获消息x的密文，然后将其改变，再将消息发送出去，这样接收者就算能成功解密，也不知道Attacker做了什么样的改变。即这种方式并不能保证数据的完整性。

数字签名=公私钥+哈希函数

通过哈希函数，我们可以很好的保证数据的完整性，即使数据呗篡改，也可以简单的检测出来，并且可以忽略消息的大小限制。

具体的流程如下：

- 发送者使用哈希函数对需要签名的文档进行散列化，然后将得到的散列值通过私钥加密得到签名
- 将文档和签名一起发送给接收者
- 接收者首先用发送者的公钥对签名进行解密验证，如成功，则证明签名来自正确的发送者；接着将整个文档进行散列化，将得到的散列值和解密后的散列值进行比较，若相同，则证明已签名后的数据文档并没有被篡改

如何知道Bob的公钥是真的还是由Attacker发布的虚假的公钥？

- **数字证书**
- **编码方式**
  - **Base58 Encode**
  - **Base58Check Encode**



### 1.2 BTC中的数据结构

- **哈希指针**：哈希指针是一个可以指向数据存储位置及保存数据的哈希值的指针。hash指针不仅可以指向数据的位置，同时它提供了一种校验数据完整性的方法。

  >区块链中的哈希指针是逻辑上的指针，实际上每个block header只保存了上一个区块的哈希值。（哈希值本身为指针）
  >
  >全节点将区块存于(key,value)数据库中，key是区块哈希值，value是区块内容，常用的数据库为levelDB。通过检索算法，可以在数据库中快速找到相应的哈希值所对应的键值对。

- **区块链**：使用哈希指针构造的链表

  tamper-evident log：可通过最后一次的哈希值来判断链中是否有区块发生改变

  > 具体数据存储于多台有能力存储的全节点中
  >
  > 分布式存储，多个节点达成共识后才可修改账本中的数据

  区块链通过网络博弈、多方校验实现了全网的容错防作恶，而区块链同步给到各节点的本地数据，需要用户自行妥善管理保存。本质上，区块链的一致性、难以篡改性是面向“**全局**”的，是由多方博弈和协作达成的，当链上交易牵涉错误数据时，共识机制可以检测并拒绝已被篡改的数据，保证链上剩余的大多数健康节点继续共识出块。而节点本地不参与共识的数据，共识机制鞭长莫及。区块链的健壮性在于，无论单个角色怎么折腾自己的节点和数据，对全局是没有影响的，只有修改者自己受损。

  - 只有构建在最长有效链上的区块才会转发新发布的区块

- **Merkel Tree**：带有hash指针的二叉树

  交易全部分布在叶子节点中，对每一个节点散列化后的哈希值存于上一个节点中，故可以通过检测根节点存储的哈希值来判断是否树种的交易被修改了。

  - Merkle Proof:证明一个交易是否存在于树中。

  > 排序Merkle 可以证明一个特定的节点不在树中

- **UTXO**: Unspent Transaction Output 

  total input = total output

  

### 1.3 BTC中的共识协议

- How to Decentralization

- 两个问题：

  1. 谁发行货币	
  2. 双重支付问题

- 分布式一致性Distributed consensus

  - Byzantine Generals Problem 
  - Sybil attack。比特币之所以是能够抵御女巫攻击的原因是各个身份之间的关系是靠POW(proof of work 工作量证明)机制去做连结的，而POW是没办法造假的。

- BTC中的共识算法

  1. 新的交易广播到所有的节点中加入到交易池中。
  2. 矿工节点收集交易池中的交易，打包到一个区块中
  3. 矿工通过Pow获得将交易写入区块的权利
  4. 其他节点验证区块中的交易是否合法（unspent，valid signatures），合法则将其加入区块链中
  5. 新的一轮挖矿，块头指向新加入区块的哈希值，继续打包交易以及Pow工作量证明。

  > 采用这种共识算法如何抵抗盗币，拒绝服务攻击，双重支付攻击？
  >
  > 1. 盗币：即使恶心节点获得了记账权，也不能盗取货币，因为一笔交易需要恶意节点创建一个有效的交易来花费该币。这将要求节点伪造所有者的签名，如果使用安全的数字签名方案，她就不能这样做。所以只要底层加密系统是可靠的，恶意节点就不能简单地窃取比特币
  >
  > 2. 拒绝服务攻击：恶意节点不打包某个用户的交易。但是在BTC网络中有许多其他节点，其中诚实节点占大多数，由于交易是随机广播到网络中的，所以这个用户的交易有很大的可能性被其他节点打包。当打包用户交易的节点获得了记账权的时候，交易就被计入区块链中。
  >
  > 3. Double-spend attack: Alice支付给Bob一笔钱，在这个交易被打包加入区块链后，假如Alice获得了下一个区块的记账权，她可以提出一个忽略包含Bob支付的block，而包含一个指向前一个block的指针的block。此外，在她提出的block中，Alice包含了一个交易，该交易将她正在发送给Bob的比特币转移到她自己控制的另一个地址中。当这个区块被加入区块链中时，造成了分叉。诚实节点遵循扩展最长有效链的策略，分叉的两个block并无不同。在实践中，节点通常遵循一种启发式的做法，即扩展它们在点对点网络中第一次听到的块。但是，这不是协议。如果真的沿着第二次提出的block扩展下去了，那么Alice就完成了double speeding。剩下的第一次提出的block称为**孤儿节点**。
  >
  > 4. Bob如何在double speeding中保护自己，为了避免这种攻击，应该多等几个block被加入到区块链中，也就是在多次确认后，再将货物交易给Alice。谨慎的商人还会监听区块中的交易，如果发现Alice有实施double speeding的意图，就不交易货物。double speeding的概率在多次确认后以指数级衰退的。BTC系统中使用的是6次确认。
  >
  > 5. 为什么确认后区块链更难发动double speeding攻击呢？
  >
  >    因为double speeding需要使区块链沿着它的节点而延长下去，使双重支付攻击的block所在的链成为最长合法链。由于每次的区块挖掘都是需要大量的算力的，在多次确认之后，分叉的攻击的block成为最长合法链的几率就显著下降了。**使用的是共识机制来避免出现这种攻击**。
  >
  > 6. 共识失败，51%攻击。
  >
  >    不能盗币，诚实的节点，不会从无效的block挖矿，仍然从原先的block链挖矿。无法对无效的交易达成共识。颠覆共识不足以盗币，颠覆密码学才行。
  >
  >    也不能拒绝交易，抑制交易。因为通过P2P网络，诚实的节点仍然会接受这些交易，诚实的节点也可能获得记账权。除非attacker掌握整个网络。
  >
  >    也不能改变block reward。在诚实节点那边无法通过。
  >
  >    

- Pow共识机制的激励措施

  1. Block Reward 区块奖励

     - BTC的来源，出块奖励产生一个铸币交易的输出

       > 挖出一个区块以后，直接获得奖励，但奖励属于类似冻结的状态，出块奖励经过100次的区块确认后，获得奖励。

     - 激励节点变得诚实

     - 通过调整难度值，区块每10分钟出一块；区块奖励每四年减少一半，最初为50个BTC；比特币总共有2100万个。

  2. Transaction fees 交易费 = total input - total output

- 使用Hash Puzzle：通过调整block header中的难度值来控制出块速度为10分钟。

  H(block header) <=target(target 越小，难度越大)

### 1.4 BTC的工作机制

#### 1、BTC系统的具体实现

1. BTC is a Transaction-based ledger

2. 交易

   - 组成：元数据，input，output
     - metadata：交易的size，input的数量，output的数量，整个交易的hash值作为交易的ID（于是我们可以用哈希指针来引用交易），lock time；
     - input：一个输入数组，输入使用哈希指针指向前一个事务，还有前一个事务输出的索引，包括签名
     - output：输出也是一个数组，每个输出只有两个字段；所有输出值的和必须小于或者等于输入值的和。输入-输出=矿工费。

   - BTC中的每一笔交易必须包括至少一个input和至少两个输出，input指明来源，output指明输出账户；一笔交易中必须将input全部花出去。由于输入-输出=矿工费，所以在交易时的找零钱必须重新指定一个属于原来账户的人所拥有的账户（可以不同于交易中所使用的）。*可以使用这种方式来将自己所有的UTXO整合到一个账户中*。

#### 2、BTC网络的工作原理

BTC工作于应用层，网络层使用P2P协议。使用的是TCP通信（有利于穿过防火墙）

节点与其他节点通信，首先需要知道seed node ，通过种子节点知道网络中的其他节点，若节点想退出网络，直接退出即可，一段时间后，其他节点自动删除与无消息节点的连接。

每个节点维护一个邻居节点的集合，消息传播在网络中 采用flooding（泛洪）的方式

- 设计原则：简单，鲁棒，而不是高效。

节点的传播属于best effort

- 目的：将交易和区块传播给所有的参与者
- **race condition**：当一个节点尝试double speeding时，一个全节点在这两个交易中，只有将第一个看到的节点加入交易池，后一个会被放弃；即使不同的全节点分别加入了两个不同的交易，那么当区块发布时也只会有一个会被包括进去；当区块打包交易时，如果已经有了一个交易，那么另一个交易会被放弃。

### 1.5 BTC中的挖矿

- 全节点
  - 一直在线
  - 在本地硬盘上维护完整的区块链信息
  - 在内存中维护UTXO集合，以便快速检验交易的合法性
  - 监听比特币网络上的交易信息，验证每一个交易的合法性
  - 决定哪些交易会被打包到区块里
  - 监听别的矿工挖出来的区块，验证其合法性
  - 挖矿
    - 沿着那条链路挖下去？
    - 当出现等长的分叉时，选择哪一个分叉?
- 轻节点
  - 不是一直在线
  - 只保存每个区块的块头
  - 不保存所以交易，只保存与自身相关的交易
  - 只能检验与自己相关交易的合法性
  - 无法检测网上发布区块的正确性
  - 可以验证挖矿的难度
  - 只能检测哪一个是最长链，不知道哪一个是最长合法链

- 挖矿是无记忆的（memoryless）不管在前一个区块的挖矿过程中做了多少努力，当进入下一个区块的挖矿时，所有节点的成功概率都一样。

- BTC保证安全性

  - 密码学机制：数字签名
  - 共识机制

- BTC的挖矿难度调整

  调整block header中的nBit（target）值来控制出块速度在10分钟每一个区块。

  difficulty=difficulty_1_target/target 其中difficulty_1_target表示难度最大，target代表当前难度。target越大就越容易

  - 如何让所有的矿工节点调整难度

    不调整的矿工发布的区块不会被系统接受，其他节点不会认同（block header中的nBits值不同）

- 矿池的出现

  - 一个全节点驱动很多矿机
    - 矿机中的区块的coinbase中存的是矿主的收款地址
  - 问题：大型矿池发动51%攻击，分叉攻击，Boycott封锁更容易

- 分叉
  - 硬分叉 **hard fork**
    - 软件更新引进了旧节点认为无效的特性，新节点认为有效
  - 软分叉 **soft fork**
    - 软件更新引进了旧节点认为有效的特性，新节点认为无效

### 1.6 BTC中的脚本

- input script 和output script

  scriptPubKey and scriptSig：最简单的情况，输出只指定公钥，输入只指定签名

  脚本语言是基于栈的，有一些特殊的指令用于计算哈希值和验证签名等操作，是非图灵完备的。

- 将input script 和output script直接拼凑在一起执行（将指令压入栈中，从上往下执行），结果要么为true，要么为false。

- **Pay-to-PubkeyHash script**

  - 将输出脚本的复杂度都留给接收者 ，发送者只需要知道脚本的哈希值。
  - 执行过程：在多重签名的场景下，input script 要给出一些签名（数目不定）及一段序列化后的redeemscript；验证分两步：
    - 验证序列化的redeemscript是否与output script中的哈希值匹配（验证赎回脚本）
    - 反序列化并执行redeemscript，验证input script 中给出的签名是否正确。（执行赎回脚本）

- **Pay-to-Script-Hash**

- **Proof of Burn**

  - 发送BTC给Proof of Burn，表明他们被销毁，永远不能再花出去；
  - one way 脚本中使用一个OP_RETURN
  - 用途：用这个方式来证明，以获得小币种；花小代价往区块链中存入永久保存的内容；

### 1.7 BTC中的匿名性